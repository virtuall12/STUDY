# 리눅스 사용자 그룹,권한

# 리눅스 사용자 그룹 생성,변경,삭제

리눅스에는 그룹(GROUP)이라는 개념이 있다.

어떤 파일이나 폴더를 특정 권한이 있는 사용자들끼리만 공유하기 위해 주로 사용한다.

**(이후에 권한 관련 포스팅에서 더 자세히 다루도록 하겠음)**

회사에서 부서별로 폴더를 만들어 해당 부서에 관련된 사람들만 파일을 열람하는 것을 예로 들 수 있겠다.

================================================================

현재 생성되어있는 그룹은 /etc/group 파일에서 확인할 수 있다.

```
# tail /etc/group

postdrop:x:90:
postfix:x:89:
chrony:x:996:
user:x:1000:
rpc:x:32:
rpcuser:x:29:
nfsnobody:x:65534:
apache:x:48:
nginx:x:995:
```

================================================================

유저의 그룹 정보를 확인하려면 'id' 명령어를 사용하면 된다.
user의 그룹 정보를 확인해보자.

```

# id user

uid=1000(user) gid=1000(user) groups=1000(user)
```

user1의 UID, GID, 그리고 속해있는 그룹에 대한 정보가 나온다.

================================================================

 그룹을 만들어보자.

그룹을 생성하는 명령어는 'groupadd' 이다.

- g 옵션을 주어 GID(그룹ID)를 직접 지정할 수 있다.

생성 후에는 그룹이 제대로 생성되었는지 확인하자.

```
# groupadd -g 777 futuregen

# tail /etc/group

postdrop:x:90:
postfix:x:89:
chrony:x:996:
user:x:1000:
rpc:x:32:
rpcuser:x:29:
nfsnobody:x:65534:
apache:x:48:
nginx:x:995:
futuregen:x:777:user
```

맨 아래줄에 방금 생성한 그룹이 추가된 것을 확인할 수 있다.

그럼, 이번에는 GID를 지정하지 않고 'test'라는 그룹을 하나 더 만들어보자.

GID는 505가 될까 778이 될까?

```
# groupadd test

# tail /etc/group

postfix:x:89:
chrony:x:996:
user:x:1000:
rpc:x:32:
rpcuser:x:29:
nfsnobody:x:65534:
apache:x:48:
nginx:x:995:
futuregen:x:777:user
test:x:1001:
```

기존에 오름차순으로 올라오던 숫자가 아닌 가장 큰 숫자를 기준으로 값이 하나씩 증가되는걸 확인할 수 있다.

그럼 이번에는 유저에 그룹을 추가시켜보자.

그룹 추가는 usermod 명령어에 -G 옵션을 주고 추가할 그룹과 유저명을 입력하면 된다.

**한 사람이 미술 동아리에도 가입할 수 있고 음악 동아리에도 가입할 수 있듯이,**

**한 유저가 여러 개의 그룹을 갖는 것이 가능하다.**

**그룹을 추가 한 후에는 id 명령어를 통해 그룹 정보를 확인해보자.**

================================================================

```
# usermod  -G futuregen user
- user에 'futuregen' 그룹을 추가시킨다.

# id user

uid=1000(user) gid=1000(user) groups=1000(user),777(futuregen)
```

user의 그룹에 'futuregen' 그룹이 추가된 것을 확인할 수 있다.

그럼 user의 그룹에 'test' 그룹을 더 추가해보자.

================================================================

```
# usermod -G test user

# id user

uid=1000(user) gid=1000(user) groups=1000(user),1001(test)
```

user1에 'test' 그룹이 추가된 것을 확인할 수 있다.

**그런데, 기존에 있던 'futuregen' 그룹이 사라졌다.**

**이처럼 명령어를 통해서는 그룹을 한 개 밖에 추가하지 못한다.**

**그룹을 세 개 이상 가지기 위해서는 /etc/group 파일을 직접 수정해야한다.**

user1에 'futuregen' 그룹을 다시 추가해보자.

================================================================

```
# vi /etc/group
- 에디터에서 futuregen 그룹 마지막 부분에 user 추가
- 저장 후 에디터 종료

ssh_keys:x:997:
sshd:x:74:
postdrop:x:90:
postfix:x:89:
chrony:x:996:
user:x:1000:
rpc:x:32:
rpcuser:x:29:
nfsnobody:x:65534:
apache:x:48:
nginx:x:995:
futuregen:x:777:user
test:x:1001:user

# id user

uid=1000(user) gid=1000(user) groups=1000(user),777(futuregen),1001(test)
```

user에 그룹 세 개가 추가된 것을 확인할 수 있다.

**이번에는 user의 기본 그룹을 'user'에서 'futuregen'으로 변경해보자**

그룹 변경은 usermod 명령어에 -g 옵션을 주고 변경할 그룹과 유저명을 입력하면 된다.

================================================================

```
# usermod -g futuregen user

# id user

uid=1000(user) gid=777(futuregen) groups=777(futuregen),1001(test)
```

위와 같이 기본 그룹이 futuregen 으로 변경된 것을 확인할 수 있다.

================================================================

마지막으로, 그룹을 삭제하려면 **groupdel** 명령어를 사용하면 된다.

**사용하려는 그룹이 어떤 사용자의 기본 그룹으로 설정되어있다면 삭제되지 않는다.**

'futuregen' 그룹을 삭제해보자.

```
# groupdel futuregen

groupdel futuregen
groupdel: 'user' 사용자의 주요 그룹을 제거할 수 없습니다
```

현재 'futuregen' 그룹이 user의 기본 그룹(주요 그룹)으로 지정되어있기 때문에 제거할 수 없다는 메세지가 뜬다.

user의 기본 그룹을 다시 'user'로 돌려놓고 'futuregen' 그룹을 삭제하자.

삭제 후에는 삭제가 제대로 되었는지 /etc/group에서 확인하자.

================================================================

```
# usermod -g user user

# groupdel futuregen

# tail /etc/group

postdrop:x:90:
postfix:x:89:
chrony:x:996:
user:x:1000:
rpc:x:32:
rpcuser:x:29:
nfsnobody:x:65534:
apache:x:48:
nginx:x:995:
test:x:1001:user
```

futuregen 그룹 삭제가 정상적으로 진행된 것을 확인할 수 있다.

================================================================

# 리눅스 권한

## (리눅스 소유권, 리눅스 허가권, 리눅스 권한)

리눅스는 다중 사용자 시스템이므로 권한이라는 개념은 매우매우 중요하다.

여러 사용자가 동시에 사용 가능하므로 파일이나 디렉토리에 대한 접근 및 실행 권한을 명확히 해주어야 하기 때문이다.

================================================================

터미널에서 ls -l 명령어를 사용하면 파일 목록을 출력해준다.

이 때, 다음과 같이 파일 목록과 함께 출력되는 알 수 없는 문자열들을 본 적이 있을 것이다.

```

# ls -l

합계 4
-rw-------. 1 root root 1643  6월 28 09:56 anaconda-ks.cfg
drwxr-xr-x  3 root root   17  7월  2 16:26 repo
-rw-r--r--  1 root root    0  6월 29 17:29 test
drwxr-xr-x  2 root root    6  7월  2 16:24 tmp
```

**맨 앞에 10자리 문자열로 된 부분을 허가권, 뒤쪽에 root root 라고 되어있는 부분을 소유권이라 칭한다.**

**개념은 둘 다 단순하다.**

**허가권은 해당 파일 및 디렉토리에 대해 '어느 수준으로 사용 권한을 허가하느냐'를 의미한다.**

**소유권은 해당 파일 및 디렉토리의 '소유자(앞부분,UID)와 소유 그룹(뒷부분,GID)'을 의미한다.**

================================================================

**소유권과 허가권을 읽는 방법에 대해 알아보자.**

- **우선 소유권을 읽는 방식은 아주 간단하다.**

**root root 라고 되어있다면 해당 파일이나 디렉토리의 소유자가 root 이고, 소유 그룹은 root라는 의미이다.**

**songjihune family 이라고 되어있다면 소유자가 songjihune, 소유 그룹은 family라는 의미이다.**

송지훈**이라는 사람의 방이 있다면 소유자는 송지훈, 소유 그룹은 가족이 되는 것에 비유할 수 있다.**

**그리고 잠을 잘 때나 작업등을 할 때에는 방에 대한 허가권을 조정해서 외부의 출입을 막을 수도 있을 것이다.**

================================================================

**그럼 허가권을 읽는 방법을 알아보자.**

**우선 10자리 문자열 중 맨 앞의 d 는 파일과 디렉토리를 구분해준다.**

d 이면 디렉토리, 하이픈(-) 표시되어있으면 파일이다.

테스트 디렉토리와 파일을 각각 하나씩 만들어 확인해보자.

```
# mkdir -p /test/testdir

# touch /test/testfile

# ls -l /test/

drwxr-xr-x 2 root root 6  7월  6 16:33 testdir
-rw-r--r-- 1 root root 0  7월  6 16:33 testfile
```

디렉토리에는 문자열 맨 앞에 d 가 붙는 것을 확인할 수 있다.

**즉, 맨 앞은 파일의 형식을 나타내는 것이고, 그 뒤의 아홉자리가 허가권이다.**

나머지 9자리 문자열을 **'허가권'** 이라고 한다.

말 그대로 파일이나 디렉토리의 사용 권한을 어느 정도까지 허가하느냐 하는 지표가 된다.

예컨대, 송지훈이라는 사람의 방에 대한 접근 및 사용 권한을 나타내는 것이다.

소유자는 송지훈이지만 바닥 공사를 한다거나 할 때에는 소유자의 접근도 막아야 할 때가 있다.

혹은, 외부인에게 방에 들어오는 것만 허용하고 물건을 건드는 것은 막아야 할 때가 있을 것이다.

허가권은 조절해 이런 접근 권한을 디테일하게 수정해줄 수 있다.

- **허가권은 9자리 문자열을 세 자리씩 끊어서 읽으면 된다.**

예를 들어 testdir의 허가권인 'rwxr-x-r-x' 의 경우,

rwx | r-x | r-x

위와 같이 세 자리씩 끊어서 읽으면 된다.

그리고 분할된 부분은 각각

**1. 파일(디렉토리)의 소유자에 대한 권한**

**2. 소유자가 속한 그룹에 대한 권한**

**3. 그리고 소유자가 아닌 나머지 일반 사용자에 대한 권한을 의미한다.**

owner(소유자)            group(그룹)          other(일반 사용자)

    rwx             |                  r-x                   |           r-x

그리고 문자열 r,w,x 는 다음 권한을 의미한다.

**r : 읽기 권한**

**w : 쓰기 권한**

**x : 실행 혹은 접근 권한을 의미한다. (파일의 경우 실행 권한, 디렉토리의 경우 접근 권한)**

(-) **: 해당 권한이 없다는 것을 의미한다.**

================================================================

이를 근거로 testdir의 허가권을 해석해보자.

rwx        |        r-x        |        r-x

1. owner(소유자)에 대한 권한이 rwx 이므로 디렉토리 소유자는 읽기, 쓰기, 접근이 모두 가능하다.

2. group(그룹)에 대한 권한은 r-x 이므로 디렉토리의 소유 그룹은 읽기와 접근이 가능하고 쓰기는 불가능하다.

3. other(일반 사용자)에 대한 권한은 r-x 이므로 일반 사용자는 읽기와 접근이 가능하고 쓰기는 불가능하다.

그리고 허가권은 숫자로도 표현할 수 있는데,

r, w, x 각 문자열마다 각각 숫자 4, 2, 1 (2의 2승, 2의 1승, 2의 0승)이 부여된다

그리고 owner, group, other 각 권한마다 이 세 개의 숫자를 더한 수를 부여한다.

마지막으로, 각 권한마다 더해져서 나온 세 개의 숫자를 이어서 부르면 된다.

말로 하면 헷갈릴 수 있으니 직접 읽어보자.

================================================================

testdir의 허가권을 숫자로 나타내면,

  **r     w     x**                |           **r     -     x**                |           **r     -     x**

4   +  2   +   1                    4   +   0  +   1                     4  +   0  +   1

     **=   7                                      =  5                                 = 5**

즉, testdir의 허가권 755 (칠오오, 혹은 칠백오십오)이다.

================================================================

testfile의 허가권인 rwxr--r--을 가지고 허가권 읽는 연습을 한 번 더 해보자.

  **r     w     x**                |           **r     -     -**                |           **r     -     -**

4   +  2   +   1                    4   +   0  +   0                     4  +   0  +   0

     **=   7                                      =  4                                 = 4**

testfile의 허가권은 744 이고,

1. owner(소유자)에 대한 권한이 rwx 이므로 디렉토리 소유자는 읽기, 쓰기, 접근이 모두 가능하다.

2. group(그룹)에 대한 권한은 r-- 이므로 디렉토리의 소유 그룹은 읽기만 가능하다.

3. other(일반 사용자)에 대한 권한은 r-- 일반 사용자는 읽기만 가능하다.

================================================================

# 리눅스 권한 변경

## (소유권 변경, 허가권 변경, chown, chmod)

리눅스는 다중 사용자 시스템이므로 여러 사용자가 동시에 사용 가능하다.

따라서, 허가권과 소유권을 적절히 조정하여 파일 및 디렉토리에 대한 접근을 제어해야한다.

만약 음악을 모아놓는 디렉토리가 있는데, 이를 FTP 서비스를 이용해 친구와 공유하는 상황을 생각해보자.

1. 실습을 하며 예를 들기 위해 간단하게 디렉토리와 파일을 생성해보자.

2. 그리고 친구 역할을 할 'friend' 유저도 생성해보자.

```
**# mkdir /music

# touch /music/ballad

# touch /music/hiphop

# touch /music/jazz

# touch /music/dance

# ls -l /music**

// 디렉토리 및 파일 생성

# useradd friend

# passwd friend

// 유저 생성 및 비밀번호 설정**
```

================================================================

생성한 네 개 파일 (ballad,dance,hiphop,jazz)의 허가권을 각각 다음과 같이 변경해보자.

변경 후에는 변경이 잘 되었는지 확인하자.

ballad : 그대로 둔다 (644)

dance : 642로 변경

hiphop : 641로 변경

dance : 640으로 변경

```
**# chmod 642 /music/dance

# chmod 641 /music/hiphop

# chmod 640 /music/jazz

# ls -l /music

-rw-r--r-- 1 root root 0  7월  7 09:00 ballad
-rw-r---w- 1 root root 0  7월  7 09:01 dance
-rw-r----x 1 root root 0  7월  7 09:01 hiphop
-rw-r----- 1 root root 0  7월  7 09:01 jazz**
```

나는 friend라는 일반 사용자(other)로 접근 할 것이므로 허가권 맨 뒤의 세 개만 보면 된다.

현재

**ballad는 읽기 권한 (r--)**

**dance는 쓰기 권한(-w-)**

**hiphop은 실행 권한(--x)** 만 있는 상태이고,

**jazz는 아무런 권한이 없는 상태이다.**

================================================================

# 리눅스 특수권한 (sticky bit, set uid, set gid)

9자리의 허가권은 3자리씩 나뉘어 각각 User, Group, Other에 대한 권한을 나타낸다는 사실을 알고있을것이다.

이렇게 나뉜 세 개의 권한 중 어떤 자리에 특정한 문자가 들어가면 이를 특수권한이라고 하는데,

User, Group, Other 중 어디에 문자가 들어가느냐에 따라 그 종류와 용도가 달라진다.

그렇다면 특수 권한이란 도대체 무엇인지 그 종류를 살펴보자.

1. SetUID

- 소유자만 접근 가능한 파일에 일반 유저로 접근이 필요할 때 사용한다. 권한을 잠시 빌려오는 개념.
- User 권한의 접근 권한(x)자리에 x대신 s가 들어가면 이를 SetUID라 칭한다.
- 만약 s 대신 S(대문자)가 들어가면 이는 일반 권한의 -(접근 권한 없음) 과 같은 의미이다.
- 권한을 읽을 때 맨 앞에 숫자 4를 붙여서 읽는다

ex) rws rwx rwx = 4777

2. SetGID

- 소유 그룹만 접근 가능한 파일에 일반 유저로 접근이 필요할 때 사용한다. 권한을 잠시 빌려오는 개념.
- Group 권한의 접근 권한(x)자리에 x대신 s가 들어가면 이를 SetGID라 칭한다.
- 만약 s 대신 S(대문자)가 들어가면 이는 일반 권한의 -(접근 권한 없음) 과 같은 의미이다.
- 권한을 읽을 때 맨 앞에 숫자 2를 붙여서 읽는다.

ex) rwx rws rwx = 2777

3. Sticky bit

- 특정 디렉토리를 누구나 자유롭게 사용할 수 있도록한다.
- 파일 및 디렉토리 생성은 누구나 가능지만, 삭제는 생성한 유저와 디렉토리 소유자만 가능하다.

**(게시판의 개념을 떠올리자)**

- Other 권한의 접근 권한(x)자리에 x대신 t가 들어가면 이를 Sticky bit라 칭한다.
- 만약 t 대신 T(대문자)가 들어가면 이는 일반 권한의 -(접근 권한 없음) 과 같은 의미이다.
- 권한을 읽을 때 맨 앞에 숫자 1을 붙여서 읽는다.

ex) rwx rwx rwt = 1777

================================================================

**SetUID 실습**

ls 명령어로 /user/bin/passwd 디렉토리의 권한을 확인해보자.

이는 흔히 사용하는 'passwd' 명령어를 실행시킬 수 있게 하는 파일이다.

```
**# ls -ld /usr/bin/passwd

-rwsr-xr-x. 1 root root 27856  8월 12  2019 /usr/bin/passwd**
```

User 허가권의 접근 권한에 s가 붙은걸로 보아 **SetUID** 특수권한이라는 것을 알 수 있다.

**이는 '4755' 로 읽을 수 있으며, 해당 파일은 root의 소유이지만 일반 사용자도 실행할 수 있음을 의미한다.**

**(즉, 일반 사용자도 마음대로 자신의 비밀번호를 변경할 수 있다)**

정말 일반 사용자도 실행할 수 있을까? 확인해보자.

우선 user1 유저를 하나 생성해준다.

================================================================

```
**# useradd user1

# passwd user1

# su user1**
```

**권한은 그대로 놔둔 채로 user1로 접속하여 비밀번호 변경 가능 여부를 확인해보자.**

Duplicate Session으로 PuTTY 창을 하나 더 열어도 괜찮고, su - 명령어를 통해 사용자를 변경해도 된다.

================================================================

user1로 접속했으면 passwd 명령어를 입력해보자. 

(root에서 사용했을 때 처럼 사용자를 지정하는것은 안 된다)

```
# passwd

user1 사용자의 비밀 번호 변경 중
user1에 대한 암호 변경 중
(현재) UNIX 암호:
새  암호: 
새  암호 재입력:
passwd: 모든 인증 토큰이 성공적으로 업데이트 되었습니다.
```

명령어가 잘 동작하는 것을 확인할 수 있다.

이는 /usr/bin/passwd 파일이 SetUID 설정이 되어있기때문이다.

- 참고로 일반 유저에서 passwd를 통해 비밀번호를 변경 할 때에는 8글자 이상으로 맞춰주어야한다.

(root에서 했을 때 처럼 단순한 비밀번호로 설정할 수 없음)

그럼 다시 관리자(root)로 접속해서 /usr/bin/passwd의 권한을 변경해보자.

================================================================

```
**# chmod 4750 /usr/bin/passwd

# ls -ld /usr/bin/passwd

-rwsr-x---. 1 root root 27856  8월 12  2019 /usr/bin/passwd**
```

여전히 SetUID 권한이지만 Other에 대한 접근을 막아놨다.

다시 user1로 접속해 passwd 명령어를 입력해보자.

================================================================

```
**# su - user1

# passwd

bash: /usr/bin/passwd: 허가 거부**
```

아까와는 달리 '허가 거부' 가 뜨는 것을 확인할 수 있다.

**이처럼 애초에 접근 권한(x)이 없는 경우는 SetUID로 실행 권한을 빌려주어도 해당 파일을 실행할 수 없다.**

================================================================

**Sticky bit 실습**

**(SetGID는 소유자 대신 그룹의 권한을 변경한다는 것 외에 SetUID와 동일한 실습이 되므로 생략)**

Sticky bit는 게시판의 개념과 비슷하다는 점을 미리 염두에 두자.

**(작성자와 관리자만이 작성된 글을 삭제 가능한 개념)**

다시 관리자(root)로 돌아와서 우선 실습을 위해 추가적으로 user2를 생성해보자.

```
**# su - root

# useradd user2

# passwd user2**
```

================================================================

Sticky bit를 적용할 디렉토리를 생성하고, Sticky bit 권한을 줘보자.

```
**# mkdir /board

# chmod 1777 /board

# ls -ld /board

drwxrwxrwt 2 root root 6  7월  7 09:58 /board/**
```

현재 디렉토리의 소유자는 root이고, /board 디렉토리는 누구나 Write 작업이 가능한 상황이다.

(Write 작업이라 함은 폴더 및 디렉토리 생성 작업 정도로 이해하면 됨)

================================================================

그럼 우선 user1로 접속해서 /board에 폴더와 디렉토리를 생성해보자.

```
**# su - user1

# mkdir /board/user1dir

# touch /board/user1file

# ls -l /board

drwxrwxr-x 2 user1 user1 6  7월  7 10:01 user1dir
-rw-rw-r-- 1 user1 user1 0  7월  7 10:02 user1file**
```

소유자가 user1로 되어있는 디렉토리와 파일이 각각 생성된 것을 확인할 수 있다.

rm 명령어로 생성한 디렉토리와 파일을 삭제해보자.

================================================================

```
**# rm -rf /board/user1dir /board/user1file

# ls -l /board

합계 0**
```

삭제가 잘 되는것을 확인할 수 있다.

그럼 다시 디렉토리와 파일을 생성하고,

이번에는 user2로 접속해서 해당 디렉토리와 파일을 삭제해보자.

================================================================

```
**# mkdir /board/user1dir

# touch /board/user1file

# su - user2

# rm -rf /board/user1dir /board/user1file

rm: cannot remove `/board/user1dir/': 명령을 허용하지 않음**
```

/board 디렉토리의 other 유저에 대한 권한이 777임에도 불구하고 삭제가 되지 않는다.

이는 /board 디렉토리가 Sticky bit (1777)로 설정되어있기 때문이다.

즉, 파일 및 디렉토리를 생성한 사람(user1)과 관리자(root) 만이 생성된 목록을 삭제할 수 있다.

게시판과 비슷한 개념으로 생각하면 된다.

================================================================

### 그룹 추가 - groupadd

groupadd 명령어로 생성되는 그룹은 특별한 옵션이 주어지지 않는 한 GID는 499 까지는 할당되지 않는다. 즉, GID 가 500 이상인 그룹들 가운데 가장 낮은 GID 번호로 그룹을 생성하게 된다( -r 옵션 사용시에는 예외).

**BASH**

```
groupadd futuregen
```

아무 옵션없이 새로운 그룹을 생성하면 기존에 있던 그룹의 마지막 번호 다음번호를 GID 로 할당하여 futuregen 라는 그룹이 생성된다.

### 특정 GID를 할당하여 그룹을 생성

**BASH**

```
groupadd -g 1000 user
```

이후부터 추가되는 그룹은 GID 가 1001 로 지정된다. 항상 가장 마지막 GID 다음 번호로 할당됨을 유념하자.

### 시스템용 그룹 (GID 499 이하)을 생성

**BASH**

```
groupadd -r futuregen
```

위와 같이 -r 옵션을 사용하면 0 번 부터 499 까지의 할당되어 있지 않은 GID 중 가장 높은 번호를 할당해 준다.

### 그룹 삭제 - groupdel

**BASH**

```
groupdel futuregen

```

### 그룹 확인 - groups

**BASH**

```
groups

  futuregen
```

### 그룹 관리 - gpasswd

리눅스 시스템을 사용하는 주체는 두가지로 볼 수 있는데 그것은 사용자이거나 그룹이다. 특정 그룹에 사용자를 추가하거나 제거하고 특정 그룹에 패스워드를 설정하는 작업은 gpasswd를 이용한다.

gpasswd 옵션

- a user : 특정 그룹에 새로운 그룹멤버를 추가함.
- d user : 특정 그룹에서 지정한 그룹멤버를 제거함.
- r : 특정 그룹의 패스워드를 제거함
- R : 특정 그룹에 접근을 제한함
- A user, ... : 특정 그룹의 그룹관리자를 설정함
- M user, ... : 특정 그룹의 그룹멤버를 새로 설정함.

위의 옵션들 가운데 -A 와 -M 외의 옵션들은 동시사용이 가능하다.

### 그룹에 사용자 추가

그룹에 사용자를 추가하는 방법 3가지

- vi 명령어로 /etc/group 파일을 편집하여 직접 등록한다.
- gpasswd 명령어의 -M 명령어로 그룹멤버를 직접 설정한다.
- gpasswd 명령어의 -a 옵션으로 새로운 멤버를 추가 등록한다.

user 사용자를 futuregen 그룹에 설정

**BASH**

```
gpasswd -a user futuregen
```

user 사용자를 futuregen 그룹에서 삭제

**BASH**

```
gpasswd -d user futuregen
```

### 특정 그룹의 그룹패스워드 설정/변경/제거

흔치 않은 일이지만 그룹에 패스워드를 설정할 경우가 생길 수 있다. 그룹의 패스워드는 /etc/gshadow 파일에 저장된다.

그룹에 패스워드 설정 및 변경

**BASH**

```
gpasswd futuregen
```

그룹에 패스워드 삭제

**BASH**

```
gpasswd -r futuregen
```

### 특정그룹멤버를 특정그룹의 그룹관리자로 설정

gpasswd 명령어 사용시 -A 옵션을 사용하면 그룹관리자를 설정할 수 있다. 단, 그룹관리자를 설정하려면 그룹정책을 보안그룹계정정책(Secure group account information)일 때에만 유효하다. 그 이유는 그룹관리자가 등록되는 파일이 /etc/shadow 파일이기 때문이다. 

futuregen 그룹의 그룹관리자로 user1를 설정한다.

**BASH**

```
gpasswd -A user1 futuregen
```

그룹관리자 확인

**BASH**

```
grep futuregen /etc/gshadow

  futuregen::user1:user1,user
```

### 특정 그룹의 그룹멤버 설정

그룹 멤버를 완전히 새로 설정하는 예이다. 즉, 기존 그룹멤버를 완전히 무시하고 새로운 그룹멤버들을 설정하는 방법이다.

**BASH**

```
gpasswd -M nestgoer,tiffiny
```

**BASH**

```
grep futuregen /etc/group

  futuregen:x:10:nestgoer,tiffiny
```